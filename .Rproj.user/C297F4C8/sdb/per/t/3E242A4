{
    "contents" : "#' DailyHydrometric\n#' \n#' @description  Gets the mean daily hydrometric series (flow or level) for \n#'    one or more stations within the Water Survey of Canada hydrometric \n#'    database (HYDAT). Flow units in m3/s; water level units in metres.\n#' \n#' @param con An open SQLite database connection\n#' @param getFlow Logical. If TRUE the function returns mean daily discharge,\n#'    otherwise the function returns mean daily water level\n#' @param stationID A vector of Water Survey of Canada station identifiers\n#' @return A data frame (STATION_NUMBER, DATE, VALUE, SYMBOL)\n#' @seealso \\code{\\link{AnnualHydrometric}} for mean annual data, \n#' \\code{\\link{MonthlyHydrometric}} for mean monthly data, \n#' \\code{\\link{DailySediment}} for mean daily sediment load/concentration,\n#' \\code{\\link{DataSymbols}} for information on symbols associated with mean daily data, and\n#' \\code{\\link{WaterLevelPrecision}} for information on water level precision\n#' @importFrom reshape2 melt\n#' @importFrom lubridate leap_year\n#' @export\nDailyHydrometric <- function(con, getFlow=TRUE, stationID) {\n  \n  table <- ifelse(getFlow, \"DLY_FLOWS\", \"DLY_LEVELS\")\n  \n  # prepare SQL command\n  sqlString <- c(\"SELECT * FROM %s \",\n                 \"WHERE STATION_NUMBER in (%s)\")\n  sqlString[1] <- sprintf(sqlString[1], table)\n  sqlString[2] <- sprintf(sqlString[2], paste(sprintf(\"\\'%s\\'\", stationID), collapse=\",\"))\n  sqlString <- paste(sqlString, collapse=\"\")\n  \n  # execute query\n  data <- dbGetQuery(con, sqlString)\n  \n  if(nrow(data)==0){\n    warning(\"No records found!\")\n    return(NULL)\n  }\n  \n  # find appropriate columns for values\n  header <- ifelse(getFlow, \"^FLOW\\\\d+\", \"^LEVEL\\\\d+\")\n  value.cols <- colnames(data)[grep(header, colnames(data))]\n  header <- ifelse(getFlow, \"^FLOW_SYMBOL\\\\d+\", \"^LEVEL_SYMBOL\\\\d+\")\n  flag.cols <- colnames(data)[grep(header, colnames(data))]\n  \n  # now melt the data frame for data and flags\n  dly.data <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), measure.vars=value.cols)\n  dly.flags <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), measure.vars=flag.cols)\n  \n  # extract flag 'value' and attach to data\n  dly.data$FLAG <- dly.flags$value\n  \n  # we now need to extract the day from the 'variable' column in the data frame\n  if(getFlow) {\n      dly.data$DAY <- as.numeric(substr(dly.data$variable, 5, 6))\n  } else {\n    dly.data$DAY <- as.numeric(substr(dly.data$variable, 6, 7))\n  }\n \n  # censor ambiguous dates (e.g., 31st day for Apr, Jun, Sept, Nov)\n  d <- which((dly.data$MONTH %in% c(4,6,9,11)) & (dly.data$DAY > 30))\n  if(length(d) > 0) {\n    dly.data <- dly.data[-d,]\n    dly.flags <- dly.flags[-d,]\n  } \n  \n  # censor ambiguous dates in February\n  d <- which((dly.data$MONTH == 2) & leap_year(dly.data$YEAR) & (dly.data$DAY > 29))\n  if(length(d)> 0) {\n    dly.data <- dly.data[-d,]\n  }\n  \n  d <- which((dly.data$MONTH == 2) & !leap_year(dly.data$YEAR) & (dly.data$DAY > 28))\n  if(length(d)>0){\n    dly.data <- dly.data[-d,]\n  }\n  \n  # coerce date\n  dly.data$DATE <- as.Date(sprintf(\"%04d-%02d-%02d\", \n                           dly.data$YEAR, dly.data$MONTH, \n                           dly.data$DAY))\n\n\n  # sort the data frame by ascending DATE\n  dly.data <- dly.data[order(dly.data$DATE),]\n  \n  return(\n    data.frame(\n      STATION_NUMBER = as.character(dly.data$STATION_NUMBER),\n      DATE = dly.data$DATE,\n      VALUE = dly.data$value,\n      SYMBOL = as.character(dly.data$FLAG),\n      stringsAsFactors = FALSE\n      )\n    )\n  \n}\n\n\n#' DailySediment\n#' @description Gets the mean daily sediment (suspended or bedload) for one or \n#'    more stations within the Water Survey of Canada hydrometric database (HYDAT).\n#'    Suspended load measured in units of mg/l. Sediment load measured in units of tonnes. \n#' @param con An open SQLite database connection \n#' @param getLoad Logical. If TRUE the function returns mean daily sediment load,\n#'    otherwise the function returns mean annual water level\n#' @param stationID A vector of Water Survey of Canada station identifiers\n#' @return A data frame \n#' @seealso \\code{\\link{DailyHydrometric}} for mean daily hydrometric data,\n#' @seealso \\code{\\link{DataSymbols}} for information on symbols associated with mean daily data\n#' @importFrom reshape2 melt\n#' @importFrom lubridate leap_year\n#' @export\nDailySediment <- function(con, getLoad=TRUE, stationID) {\n  require(reshape)\n  require(lubridate)\n  \n  table <- ifelse(getLoad, \"SED_DLY_LOADS\", \"SED_DLY_SUSCON\")\n  \n  # prepare SQL command\n  sqlString <- c(\"SELECT * FROM %s \",\n                 \"WHERE STATION_NUMBER in (%s)\")\n  sqlString[1] <- sprintf(sqlString[1], table)\n  sqlString[2] <- sprintf(sqlString[2], paste(sprintf(\"\\'%s\\'\", stationID), collapse=\",\"))\n  sqlString <- paste(sqlString, collapse=\"\")\n  \n  # execute query\n  data <- dbGetQuery(con, sqlString)\n\n  if(nrow(data)==0){\n    warning(\"No records found!\")\n    return(NULL)\n  }\n  \n  # find appropriate columns for values\n  header <- ifelse(getLoad, \"^LOAD\\\\d+\", \"^SUSCON\\\\d+\")\n  value.cols <- colnames(data)[grep(header, colnames(data))]\n  \n  # now melt the data frame for data values\n  dly.data <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), measure.vars=value.cols)\n  \n  # symbols/flags only exist for suspended sediment\n  if(!getLoad) {\n    flag.cols <- colnames(data)[grep(\"^SUSCON_SYMBOL\\\\d+\", colnames(data))]\n    dly.flags <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), measure.vars=flag.cols)\n    # extract flag 'value' and attach to data\n    dly.data$FLAG <- dly.flags$value\n  }\n  \n  # we now need to extract the day from the 'variable' column in the data frame\n  dly.data$DAY <- as.numeric(gsub(ifelse(getLoad,\"LOAD\",\"SUSCON\"),\"\",dly.data$variable))\n  \n  # censor ambiguous dates (e.g., 31st day for Apr, Jun, Sept, Nov)\n  d <- which((dly.data$MONTH %in% c(4,6,9,11)) & (dly.data$DAY > 30))\n  dly.data <- dly.data[-d,]\n  \n  # censor ambiguous dates in February\n  d <- which((dly.data$MONTH == 2) & leap_year(dly.data$YEAR) & (dly.data$DAY > 29))\n  if(length(d)> 0) {\n    dly.data <- dly.data[-d,]\n  }\n  \n  d <- which((dly.data$MONTH == 2) & !leap_year(dly.data$YEAR) & (dly.data$DAY > 28))\n  if(length(d)>0){\n    dly.data <- dly.data[-d,]\n  }\n  \n  # coerce date\n  dly.data$DATE <- as.Date(sprintf(\"%04d-%02d-%02d\", \n                                   dly.data$YEAR, dly.data$MONTH, \n                                   dly.data$DAY))\n  \n  # sort the data frame by ascending DATE\n  dly.data <- dly.data[order(dly.data$DATE),]\n  \n  # create output data frame\n  output <- data.frame(\n              STATION_NUMBER = dly.data$STATION_NUMBER,\n              DATE = dly.data$DATE,\n              VALUE = dly.data$value,\n              stringsAsFactors = FALSE\n            )\n  \n  # add flag if suspended sed\n  if(!getLoad) {\n    output$SYMBOL = dly.data$FLAG\n  }\n\n  return(output)\n  \n}\n\n\n\n",
    "created" : 1446580313704.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "19|60|95|0|\n112|57|189|0|\n",
    "hash" : "2389633895",
    "id" : "3E242A4",
    "lastKnownWriteTime" : 1447819333,
    "path" : "~/R_LIBRARY/HYDAT/R/ReadDaily.r",
    "project_path" : "R/ReadDaily.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}