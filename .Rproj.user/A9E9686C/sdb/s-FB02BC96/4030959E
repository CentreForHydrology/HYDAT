{
    "collab_server" : "",
    "contents" : "#' @title Gets mean daily hydrometric data for selected station(s)\n#' @description  Gets the mean daily hydrometric series (flow or level) for \n#'    one or more stations. Flow units in m3/s; water level units in metres.\n#' @param con An open SQLite database connection to the HYDAT database\n#' @param get_flow Logical. If TRUE the function returns mean daily discharge,\n#'    otherwise the function returns mean daily water level\n#' @param station_number A vector of Water Survey of Canada station identifiers\n#' @return A data frame (station_number, date, value, symbol)\n#' @note Symbols associated with mean daily hydrometric series are as follows\n#'  \"A\" - manual gauge\n#'  \"B\" - ice affected \n#'  \"D\" - dry \n#'  \"E\" - estimated\n#' @seealso \\code{\\link{AnnualHydrometricData}} for mean annual data, \n#' \\code{\\link{MonthlyHydrometricData}} for mean monthly data, \n#' \\code{\\link{DailySedimentData}} for mean daily sediment load/concentration,\n#' \\code{\\link{DataSymbols}} for information on symbols associated with mean daily data, and\n#' \\code{\\link{ReportedWaterLevelPrecision}} for information on water level precision\n#' @importFrom reshape2 melt\n#' @importFrom lubridate leap_year\n#' @importFrom DBI dbGetQuery\n#' @export\nDailyHydrometricData <- function(con, get_flow=TRUE, station_number) {\n  \n  # determine database table to pull data from (flows or levels)\n  tableName <- ifelse(get_flow, \"DLY_FLOWS\", \"DLY_LEVELS\")\n  \n  # prepare SQL command\n  sqlString <- c(\"SELECT * FROM %s \",\n                 \"WHERE STATION_NUMBER in (%s)\")\n  sqlString[1] <- sprintf(sqlString[1], tableName)\n  sqlString[2] <- sprintf(sqlString[2], \n                          paste(sprintf(\"\\'%s\\'\", station_number), collapse=\",\"))\n  sqlString <- paste(sqlString, collapse=\"\")\n  \n  data <- dbGetQuery(con, sqlString) \n  \n  if(nrow(data)==0){\n    warning(\"No daily hydrometric records found!\")\n    return(NULL)\n  }\n  \n  # find appropriate columns for values\n  header <- ifelse(get_flow, \"^FLOW\\\\d+\", \"^LEVEL\\\\d+\")\n  value.cols <- colnames(data)[grep(header, colnames(data))]\n  header <- ifelse(get_flow, \"^FLOW_SYMBOL\\\\d+\", \"^LEVEL_SYMBOL\\\\d+\")\n  flag.cols <- colnames(data)[grep(header, colnames(data))]\n  \n  # now melt the data frame for data and flags\n  dly.data <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), \n                   measure.vars=value.cols)\n  dly.flags <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), \n                    measure.vars=flag.cols)\n  \n  # extract flag 'value' and attach to data\n  dly.data$FLAG <- dly.flags$value\n  \n  # we now need to extract the day from the 'variable' column in the data frame\n  if(get_flow) {\n      dly.data$DAY <- as.numeric(substr(dly.data$variable, 5, 6))\n  } else {\n    dly.data$DAY <- as.numeric(substr(dly.data$variable, 6, 7))\n  }\n \n  # censor ambiguous dates (e.g., 31st day for Apr, Jun, Sept, Nov)\n  d <- which((dly.data$MONTH %in% c(4,6,9,11)) & (dly.data$DAY > 30))\n  if(length(d) > 0) {\n    dly.data <- dly.data[-d,]\n    dly.flags <- dly.flags[-d,]\n  } \n  \n  # censor ambiguous dates in February\n  d <- which((dly.data$MONTH == 2) & leap_year(dly.data$YEAR) & (dly.data$DAY > 29))\n  if(length(d)> 0) {\n    dly.data <- dly.data[-d,]\n  }\n  \n  d <- which((dly.data$MONTH == 2) & !leap_year(dly.data$YEAR) & (dly.data$DAY > 28))\n  if(length(d)>0){\n    dly.data <- dly.data[-d,]\n  }\n  \n  # coerce date\n  dly.data$DATE <- as.Date(sprintf(\"%04d-%02d-%02d\", \n                           dly.data$YEAR, dly.data$MONTH, \n                           dly.data$DAY))\n\n\n  # sort the data frame by ascending DATE\n  dly.data <- dly.data[order(dly.data$DATE),]\n  \n  return(\n    data.frame(\n      station_number = dly.data$STATION_NUMBER, #as.character(dly.data$STATION_NUMBER),\n      date = dly.data$DATE,\n      value = dly.data$value,\n      symbol = as.character(dly.data$FLAG),\n      stringsAsFactors = FALSE\n      )\n    )\n  \n}\n\n\n#' @title Gets mean daily sediment data for selected station(s)\n#' @description Gets the mean daily suspended sediment (concentration or load)\n#'  for one or more stations. Concentrations are measured in units of mg/L. Load \n#'  are measured in tonnes (mean daily conc * mean daily flow * 0.0864). \n#' @param con An open SQLite database connection to the HYDAT database\n#' @param get_load Logical. If TRUE the function returns mean daily load,\n#'    otherwise the function returns mean daily concentration.\n#' @param station_number A vector of Water Survey of Canada station identifiers\n#' @return A data frame (station_number, date, value). \n#' @note Symbols associated with mean daily sediment series are as follows:\n#' <<need further work here>>\n#' @seealso \\code{\\link{DailyHydrometricData}} for mean daily hydrometric data,\n#' @seealso \\code{\\link{DataSymbols}} for information on symbols associated with mean daily data\n#' @importFrom reshape2 melt\n#' @importFrom lubridate leap_year\n#' @importFrom DBI dbGetQuery\n#' @export\nDailySedimentData <- function(con, get_load=TRUE, station_number) {\n\n  tableName <- ifelse(get_load, \"SED_DLY_LOADS\", \"SED_DLY_SUSCON\")\n  \n  # prepare SQL command\n  sqlString <- c(\"SELECT * FROM %s \",\n                 \"WHERE STATION_NUMBER in (%s)\")\n  sqlString[1] <- sprintf(sqlString[1], tableName)\n  sqlString[2] <- sprintf(sqlString[2], \n                          paste(sprintf(\"\\'%s\\'\", station_number), collapse=\",\"))\n  sqlString <- paste(sqlString, collapse=\"\")\n  \n  data <- dbGetQuery(con, sqlString)\n  \n  # find appropriate columns for values\n  header <- ifelse(get_load, \"^LOAD\\\\d+\", \"^SUSCON\\\\d+\")\n  value.cols <- colnames(data)[grep(header, colnames(data))]\n  \n  # now melt the data frame for data values\n  dly.data <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), \n                   measure.vars=value.cols)\n  \n  # symbols/flags only exist for suspended sediment\n  if(!get_load) {\n    flag.cols <- colnames(data)[grep(\"^SUSCON_SYMBOL\\\\d+\", colnames(data))]\n    dly.flags <- melt(data, id.vars=c(\"STATION_NUMBER\", \"YEAR\", \"MONTH\"), \n                      measure.vars=flag.cols)\n    # extract flag 'value' and attach to data\n    dly.data$FLAG <- dly.flags$value\n  }\n  \n  # we now need to extract the day from the 'variable' column in the data frame\n  dly.data$DAY <- as.numeric(gsub(ifelse(get_load,\"LOAD\",\"SUSCON\"), \n                                  \"\", dly.data$variable))\n  \n  # censor ambiguous dates (e.g., 31st day for Apr, Jun, Sept, Nov)\n  d <- which((dly.data$MONTH %in% c(4,6,9,11)) & (dly.data$DAY > 30))\n  dly.data <- dly.data[-d,]\n  \n  # censor ambiguous dates in February\n  d <- which((dly.data$MONTH == 2) & leap_year(dly.data$YEAR) & (dly.data$DAY > 29))\n  if(length(d)> 0) {\n    dly.data <- dly.data[-d,]\n  }\n  \n  d <- which((dly.data$MONTH == 2) & !leap_year(dly.data$YEAR) & (dly.data$DAY > 28))\n  if(length(d)>0){\n    dly.data <- dly.data[-d,]\n  }\n  \n  # coerce date\n  dly.data$DATE <- as.Date(sprintf(\"%04d-%02d-%02d\", \n                                   dly.data$YEAR, dly.data$MONTH, \n                                   dly.data$DAY))\n  \n  # sort the data frame by ascending DATE\n  dly.data <- dly.data[order(dly.data$DATE),]\n  \n  # create output data frame\n  output <- data.frame(\n              station_number = dly.data$STATION_NUMBER,\n              date = dly.data$DATE,\n              value = dly.data$value,\n              stringsAsFactors = FALSE\n            )\n  \n  # add flag if suspended sediment\n  if(!get_load) {\n    output$symbol = dly.data$FLAG\n  }\n\n  return(output)\n  \n}\n\n\n\n",
    "created" : 1484447170512.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3028002438",
    "id" : "4030959E",
    "lastKnownWriteTime" : 1484538711,
    "last_content_update" : 1484538711630,
    "path" : "~/Documents/PACKAGES/HYDAT/R/Daily_Data.r",
    "project_path" : "R/Daily_Data.r",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}